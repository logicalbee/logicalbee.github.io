<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sushanth Kurdekar (Logical Bee) on Sushanth Kurdekar</title><link>https://logicalbee.github.io/</link><description>Recent content in Sushanth Kurdekar (Logical Bee) on Sushanth Kurdekar</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 27 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://logicalbee.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting serious with home server and self-hosting</title><link>https://logicalbee.github.io/projects/homelab-v2/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/projects/homelab-v2/</guid><description>&lt;p>In one of my last &lt;a href="https://manosriram.com/posts/homelab/">posts&lt;/a>, I was getting started with a home server using a Raspberry PI 4. Since then, I have upgraded the setup and the hardware as well.&lt;/p>
&lt;p>The RPi had 8GB of RAM, but it was not very stable for a home server. By stability, I mean: stable storage, faster RAM, faster processor, more ports, etc Since starting with the home server with RPi, I wanted to have some regularly used services rather than just hosting whatever I like. For example, in the last post, I said I hosted memos for note-taking, but it didn&amp;rsquo;t work. I didn&amp;rsquo;t see myself using it very much (not at all, actually). I understood that this is kind of a trial-and-error method, but I need to have a few services that I actually use regularly.&lt;/p></description></item><item><title>How i make use of LLMs</title><link>https://logicalbee.github.io/posts/llm/</link><pubDate>Wed, 23 Apr 2025 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/llm/</guid><description>&lt;p>Frequency of the use of LLMs have increased a lot for me in the past year specifically. I use claude as my daily driver. I do not pay for the pro plan, but I do have API credits to work with which I am going to talk about.&lt;/p>
&lt;h3 id="aider">Aider&lt;/h3>
&lt;p>Recently discovered this tool to interact locally using codebases. This works great for me. Its very convenient to use llms from the terminal.&lt;/p></description></item><item><title>Abstract syntax trees</title><link>https://logicalbee.github.io/posts/abstract-syntax-trees/</link><pubDate>Sun, 12 Jan 2025 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/abstract-syntax-trees/</guid><description>&lt;p>ASTs are a representation of the code. It converts a bunch of meaningless tokens into a tree which represents the code.
When the code is seen in the form of tree, multiple usecases arise such as:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Static code analysis - Analyze and find issues in code without executing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Transform code - ASTs can be used to transform code to some other form.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>We will try to create an AST for the expression &amp;lsquo;1 + 2 * 3&amp;rsquo;. Since this is a single expression, there will be one node. If there are multiple expressions and statements, we store them separately
in a list and execute them separately.&lt;/p></description></item><item><title>Making time to learn software design patterns</title><link>https://logicalbee.github.io/posts/design-patterns/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/design-patterns/</guid><description>&lt;p>Inorder to write well structured, extensible, and readable code - design patterns help. I have recently started to read and follow more on this path. Until now, I didn&amp;rsquo;t care much about these patterns (although some design patterns are just patterns we do frequently without knowing).&lt;/p>
&lt;p>In 1994, 4 people came together to write the book &lt;code>Design Patterns: Elements of Reusable Object-Oriented Software&lt;/code>. It became a standard for the design patterns and since then the book was also called as &lt;code>The gang-of-four(gof) book&lt;/code>.&lt;/p></description></item><item><title>Handling concurrency in KeyValue stores</title><link>https://logicalbee.github.io/posts/key-value-concurrency/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/key-value-concurrency/</guid><description>&lt;p>Key value stores might seem simple from outer view. We set and get the values which I thought the same. However, things get tricky as we dive deep. The problem is that, what happens if few processes write a key at the same time, and few processes read the same key.&lt;/p>
&lt;p>We can actually simulate this using &lt;code>goroutines&lt;/code> in golang.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">numGoRoutines&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">numGoRoutines&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">numGoRoutines&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">kv&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">nimbusdb&lt;/span>.&lt;span style="color:#a6e22e">KeyValuePair&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">Key&lt;/span>: []byte(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">Value&lt;/span>: []byte(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;testvalue%d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">writtenKvPair&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Set&lt;/span>(&lt;span style="color:#a6e22e">kv&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code creates 1000 goroutines each setting a different value. But, the problem is that multiple go routines can touch the variable where the keyvalue pairs are stored. Why is that a problem? Because we want to be 100% sure that only one process is using the variable at a given moment, which you might have guessed that we&amp;rsquo;ll use locks.&lt;/p></description></item><item><title>Key Value Store internals</title><link>https://logicalbee.github.io/posts/key-value-stores/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/key-value-stores/</guid><description>&lt;h1 id="key-value-store-and-a-cache">Key Value store and a Cache&lt;/h1>
&lt;p>Doesn&amp;rsquo;t Cache use key value to store objects? Then why do we need a key value store?&lt;/p>
&lt;p>The answer is simple, persistence.
A key-value store is a database but instead of tables and other complex stuff, we simply use a key value structure. Cache&amp;rsquo;s main purpose is to increase read performance.
Anything you think doesnt change that often, you can cache it. Whereas, KV store focuses more on writes along with reads.&lt;/p></description></item></channel></rss>