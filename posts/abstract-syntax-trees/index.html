<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://logicalbee.github.io/favicon.svg><title>Abstract syntax trees | Sushanth Kurdekar</title><meta name=title content="Abstract syntax trees"><meta name=description content="Understanding Abstract syntax trees by writing one"><meta name=keywords content><meta property="og:url" content="https://logicalbee.github.io/posts/abstract-syntax-trees/"><meta property="og:site_name" content="Sushanth Kurdekar"><meta property="og:title" content="Abstract syntax trees"><meta property="og:description" content="Understanding Abstract syntax trees by writing one"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-12T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Abstract syntax trees"><meta name=twitter:description content="Understanding Abstract syntax trees by writing one"><meta itemprop=name content="Abstract syntax trees"><meta itemprop=description content="Understanding Abstract syntax trees by writing one"><meta itemprop=datePublished content="2025-01-12T00:00:00+00:00"><meta itemprop=dateModified content="2025-01-12T00:00:00+00:00"><meta itemprop=wordCount content="770"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:800px;--font-main:'Crimson Text', 'Libre Baskerville', 'Source Serif Pro', 'Bitstream Charter', Georgia, 'Times New Roman', serif;--font-secondary:'Crimson Text', 'Libre Baskerville', 'Source Serif Pro', 'Bitstream Charter', Georgia, 'Times New Roman', serif;--font-mono:'Fira Code', 'JetBrains Mono', 'SF Mono', Monaco, Inconsolata, 'Roboto Mono', 'Source Code Pro', monospace;--font-scale:1.2em;--line-height:1.6;--spacing:1.5rem;--border-radius:8px;--shadow:0 2px 10px rgba(0, 0, 0, 0.1);--transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1)}[data-theme=light],:root{--background-color:#ffffff;--background-secondary:#f8f9fa;--heading-color:#1a202c;--text-color:#2d3748;--text-muted:#718096;--link-color:#3182ce;--link-hover:#2c5aa0;--visited-color:#805ad5;--border-color:#e2e8f0;--code-background:#1a202c;--code-color:#f7fafc;--code-inline-bg:#edf2f7;--code-inline-color:#e53e3e;--blockquote-bg:#edf2f7;--blockquote-border:#cbd5e0;--blockquote-color:#4a5568;--selection-bg:#bee3f8;--focus-ring:#3182ce}[data-theme=dark]{--background-color:#0f1419;--background-secondary:#1a202c;--heading-color:#f7fafc;--text-color:#e2e8f0;--text-muted:#a0aec0;--link-color:#63b3ed;--link-hover:#90cdf4;--visited-color:#b794f6;--border-color:#2d3748;--code-background:#1a202c;--code-color:#f7fafc;--code-inline-bg:#2d3748;--code-inline-color:#fbb6ce;--blockquote-bg:#1a202c;--blockquote-border:#4a5568;--blockquote-color:#cbd5e0;--selection-bg:#2d3748;--focus-ring:#63b3ed}*{box-sizing:border-box}::selection{background-color:var(--selection-bg)}body{font-family:var(--font-secondary);font-size:var(--font-scale);line-height:var(--line-height);margin:0;padding:var(--spacing);max-width:var(--width);margin-left:auto;margin-right:auto;background-color:var(--background-color);color:var(--text-color);word-wrap:break-word;overflow-wrap:break-word;transition:var(--transition);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);font-weight:700;color:var(--heading-color);line-height:1.3;margin-top:2em;margin-bottom:.5em;letter-spacing:-.025em}h1{font-size:2.5rem}h2{font-size:2rem}h3{font-size:1.5rem}h4{font-size:1.25rem}h5{font-size:1.125rem}h6{font-size:1rem}p{margin-bottom:var(--spacing);color:var(--text-color)}a{color:var(--link-color);text-decoration:none;transition:var(--transition);border-radius:2px}a:hover{color:var(--link-hover)}a:focus{outline:2px solid var(--focus-ring);outline-offset:2px}a:visited{color:var(--visited-color)}nav{display:flex;align-items:center;justify-content:space-between;margin-bottom:calc(var(--spacing) * 2);padding-bottom:var(--spacing);border-bottom:1px solid var(--border-color);flex-wrap:wrap;gap:1rem;font-style:italic}nav .nav-links{display:flex;gap:1.5rem;align-items:center}nav a{font-weight:500;padding:.5rem 0}.theme-toggle{background:var(--background-secondary);border:1px solid var(--border-color);color:var(--text-color);padding:.5rem 1rem;border-radius:var(--border-radius);cursor:pointer;font-size:.875rem;font-weight:500;transition:var(--transition);display:flex;align-items:center;gap:.5rem}.theme-toggle:hover{background-color:var(--text-color);color:var(--background-color);transform:translateY(-1px)}main{margin-bottom:calc(var(--spacing) * 3)}code{font-family:var(--font-mono);font-size:.9em;font-weight:500;letter-spacing:.025em}:not(pre)>code{background-color:var(--code-inline-bg);color:var(--code-inline-color);padding:.2rem .4rem;border-radius:4px;font-weight:600;font-size:.85em}pre{background-color:var(--code-background);color:var(--code-color);padding:1.5rem;border-radius:var(--border-radius);overflow-x:auto;margin:var(--spacing)0;box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,6%);border:1px solid var(--border-color);position:relative;font-size:1em;line-height:1.6}[data-theme=dark] pre{box-shadow:0 4px 6px -1px rgba(0,0,0,.3),0 2px 4px -1px rgba(0,0,0,.2)}pre code{background-color:transparent;color:inherit;padding:0;border-radius:0;font-size:.85em;font-weight:400;letter-spacing:inherit}pre[data-lang]::before{content:attr(data-lang);position:absolute;top:.5rem;right:1rem;font-size:.85rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:.05em;font-weight:600}blockquote{background-color:var(--blockquote-bg);border-left:4px solid var(--link-color);color:var(--blockquote-color);padding:1rem 1.5rem;margin:var(--spacing)0;border-radius:0 var(--border-radius)var(--border-radius)0;font-style:italic}blockquote p:last-child{margin-bottom:0}ul,ol{margin:var(--spacing)0;padding-left:2rem}li{margin-bottom:.5rem}table{width:100%;border-collapse:collapse;margin:var(--spacing)0;border-radius:var(--border-radius);overflow:hidden;box-shadow:var(--shadow)}th,td{padding:.75rem 1rem;text-align:left;border-bottom:1px solid var(--border-color)}th{background-color:var(--background-secondary);font-weight:600;color:var(--heading-color)}img{max-width:100%;height:auto;border-radius:var(--border-radius);margin:var(--spacing)0;box-shadow:0 10px 25px -5px rgba(0,0,0,.1),0 10px 10px -5px rgba(0,0,0,4%);transition:var(--transition);border:1px solid var(--border-color)}[data-theme=dark] img{box-shadow:0 10px 25px -5px rgba(0,0,0,.4),0 10px 10px -5px rgba(0,0,0,.2);border-color:rgba(255,255,255,.1)}img:hover{transform:translateY(-2px);box-shadow:0 20px 40px -10px rgba(0,0,0,.15),0 10px 20px -5px rgba(0,0,0,8%)}[data-theme=dark] img:hover{box-shadow:0 20px 40px -10px rgba(0,0,0,.5),0 10px 20px -5px rgba(0,0,0,.3)}img+em,figure figcaption{display:block;text-align:center;font-style:italic;font-size:.875rem;color:var(--text-muted);margin-top:.5rem;margin-bottom:var(--spacing)}figure{margin:var(--spacing)0;text-align:center}figure img{margin-bottom:.5rem}hr{border:0;height:1px;background:var(--border-color);margin:calc(var(--spacing) * 2)0}button{font-family:inherit;cursor:pointer;border:none;border-radius:var(--border-radius);transition:var(--transition)}button:focus{outline:2px solid var(--focus-ring);outline-offset:2px}.title{margin-bottom:calc(var(--spacing) * 2)}.title:hover{text-decoration:none}.title h1{margin:0;font-size:2.5rem;background:linear-gradient(135deg,var(--link-color),var(--visited-color));background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}.inline{width:auto !important}time{font-family:var(--font-mono);font-size:.875rem;color:var(--text-muted);font-weight:500}strong,b{color:var(--heading-color);font-weight:600}ul.blog-posts{list-style:none;padding:0;margin:calc(var(--spacing) * 2)0}ul.blog-posts li{display:flex;align-items:baseline;gap:1rem;padding:.75rem 0;border-bottom:1px solid var(--border-color);transition:var(--transition)}ul.blog-posts li:hover{background-color:var(--background-secondary);margin:0 -1rem;padding-left:1rem;padding-right:1rem;border-radius:var(--border-radius)}ul.blog-posts li:last-child{border-bottom:none}ul.blog-posts li time{flex-shrink:0;min-width:120px;font-size:.85rem}ul.blog-posts li a{font-weight:500;flex:1}ul.blog-posts li a:visited{color:var(--visited-color)}footer{padding:calc(var(--spacing) * 2)0;text-align:center;border-top:1px solid var(--border-color);color:var(--text-muted);font-size:.875rem}@media(max-width:768px){:root{--font-scale:1rem;--spacing:1rem;--width:100%}body{padding:1rem}h1{font-size:2rem}h2{font-size:1.75rem}h3{font-size:1.375rem}nav{flex-direction:column;align-items:stretch}nav .nav-links{justify-content:center}.theme-toggle{align-self:center}ul.blog-posts li{flex-direction:column;align-items:flex-start;gap:.25rem}ul.blog-posts li time{min-width:auto}pre{padding:1rem;margin-left:-1rem;margin-right:-1rem;border-radius:0}}@media print{body{background:#fff;color:#000;font-size:12pt;line-height:1.4}.theme-toggle{display:none}a{color:#000}pre{background:#f5f5f5;border:1px solid #ccc}}@media(prefers-reduced-motion:reduce){*{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}</style></head><body><header><a href=/ class=title><h2>Sushanth Kurdekar</h2></a><nav><a href=/>home</a>
<a href=/posts/>blog</a>
<a href=/projects/>projects</a>
<a href=/resume.pdf>resume</a>
<button class=theme-toggle aria-label="Switch to dark mode">üåô</button></nav></header><main><content><p>ASTs are a representation of the code. It converts a bunch of meaningless tokens into a tree which represents the code.
When the code is seen in the form of tree, multiple usecases arise such as:</p><ol><li><p>Static code analysis - Analyze and find issues in code without executing.</p></li><li><p>Transform code - ASTs can be used to transform code to some other form.</p></li></ol><p>We will try to create an AST for the expression &lsquo;1 + 2 * 3&rsquo;. Since this is a single expression, there will be one node. If there are multiple expressions and statements, we store them separately
in a list and execute them separately.</p><p>These tokens are considered to keep things simple:
TokenType.PLUS
TokenType.MULTIPLY
TokenType.INTEGER</p><p>To create an AST, we&rsquo;ll recursively keep parsing the code. One thing that comes up when parsing is to handle priority, ie * has greater priority compared to +</p><p>We have 3 (expr, term, and factor) methods to recurse.</p><p>The hierarchy looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>factor</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>term</span>():
</span></span><span style=display:flex><span>    factor()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>expr</span>():
</span></span><span style=display:flex><span>    term()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>expr()
</span></span></code></pre></div><p>expr is first called method which calls term, which calls factor. Higher priority tokens are parsed earlier when recursing so that it is found before lower priority.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>factor</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> current_token <span style=color:#f92672>==</span> TokenType<span style=color:#f92672>.</span>PLUS:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>eat(current_token)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Literal(current_token)
</span></span></code></pre></div><p>This block of code checks if the current token is a literal and then returns a Literal class. Since factor method returns the smallest unit in AST, we return Literal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>term</span>():
</span></span><span style=display:flex><span>    node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>factor()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> current_token <span style=color:#f92672>in</span> [TokenType<span style=color:#f92672>.</span>MULTIPLY]:
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> current_token
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>eat(current_token)
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> BinOp(left<span style=color:#f92672>=</span>node, op<span style=color:#f92672>=</span>token, right<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>factor())
</span></span></code></pre></div><p>term method first calls factor (since this is a recursive parser), and then uses the result when returning a BinOp. This will return a BinOp since PLUS has a left and right. If this
is something like <code>!True</code>, then UnaryOp will be used. factor is again called for right node as well to use the result to the right side of MULTIPLY. This is done until current token
is not a MULTIPLY token.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>expr</span>():
</span></span><span style=display:flex><span>    node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>term()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type <span style=color:#f92672>in</span> [TokenType<span style=color:#f92672>.</span>PLUS]:
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>current_token
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>eat(self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type)
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> BinOp(left<span style=color:#f92672>=</span>node, op<span style=color:#f92672>=</span>token, right<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>term())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> node
</span></span></code></pre></div><p>expr method similarly calls term, and again uses that in the left and right nodes of the BinOp. This is done until current token is not a PLUS token.</p><p>Putting these together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>from</span> tokenize <span style=color:#f92672>import</span> TokenType, Tokenizer <span style=color:#75715e># refer https://github.com/manosriram/ast/blob/main/tokenize.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AST</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Literal</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, token) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>type <span style=color:#f92672>=</span> token<span style=color:#f92672>.</span>type
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> token<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinOp</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, left, op, right) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>op <span style=color:#f92672>=</span> op
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>tree <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AstBuilder</span>(AST):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, tokens) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>position <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tokens <span style=color:#f92672>=</span> tokens
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tokens[self<span style=color:#f92672>.</span>position] <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>tokens) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>nodes <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self, token_type):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> token_type <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>position <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tokens[self<span style=color:#f92672>.</span>position] <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>position <span style=color:#f92672>&lt;</span> len(self<span style=color:#f92672>.</span>tokens) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;error parsing source at line </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>factor</span>(self):
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>current_token
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> token<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> TokenType<span style=color:#f92672>.</span>INTEGER:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>eat(token<span style=color:#f92672>.</span>type)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Literal(token)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> token<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> TokenType<span style=color:#f92672>.</span>LPAREN:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>eat(TokenType<span style=color:#f92672>.</span>LPAREN)
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>expr()
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>eat(TokenType<span style=color:#f92672>.</span>RPAREN)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;error parsing source at line </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>term</span>(self):
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>factor()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type <span style=color:#f92672>in</span> [TokenType<span style=color:#f92672>.</span>MULTIPLY, TokenType<span style=color:#f92672>.</span>DIVIDE]:
</span></span><span style=display:flex><span>            token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>current_token
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>eat(self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type)
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> BinOp(left<span style=color:#f92672>=</span>node, op<span style=color:#f92672>=</span>token, right<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>factor())
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>expr</span>(self):
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>term()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type <span style=color:#f92672>in</span> [TokenType<span style=color:#f92672>.</span>PLUS, TokenType<span style=color:#f92672>.</span>MINUS]:
</span></span><span style=display:flex><span>            token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>current_token
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>eat(self<span style=color:#f92672>.</span>current_token<span style=color:#f92672>.</span>type)
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> BinOp(left<span style=color:#f92672>=</span>node, op<span style=color:#f92672>=</span>token, right<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>term())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>walk</span>(self, node):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> type(node) <span style=color:#f92672>==</span> BinOp:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>walk(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>walk(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                print(node<span style=color:#f92672>.</span>value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate</span>(self, node):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> type(node) <span style=color:#f92672>==</span> BinOp:
</span></span><span style=display:flex><span>            left_val <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>calculate(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>            right_val <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>calculate(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>op<span style=color:#f92672>.</span>value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;+&#39;</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> left_val <span style=color:#f92672>+</span> right_val <span style=color:#66d9ef>if</span> left_val <span style=color:#f92672>and</span> right_val <span style=color:#66d9ef>else</span> left_val <span style=color:#f92672>or</span> right_val
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>op<span style=color:#f92672>.</span>value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> left_val <span style=color:#f92672>-</span> right_val <span style=color:#66d9ef>if</span> left_val <span style=color:#f92672>and</span> right_val <span style=color:#66d9ef>else</span> left_val <span style=color:#f92672>or</span> right_val
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>op<span style=color:#f92672>.</span>value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;*&#39;</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> left_val <span style=color:#f92672>*</span> right_val <span style=color:#66d9ef>if</span> left_val <span style=color:#f92672>and</span> right_val <span style=color:#66d9ef>else</span> left_val <span style=color:#f92672>or</span> right_val
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>op<span style=color:#f92672>.</span>value <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> left_val <span style=color:#f92672>/</span> right_val <span style=color:#66d9ef>if</span> left_val <span style=color:#f92672>and</span> right_val <span style=color:#66d9ef>else</span> left_val <span style=color:#f92672>or</span> right_val
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> type(node) <span style=color:#f92672>==</span> Literal:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> int(node<span style=color:#f92672>.</span>value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> self<span style=color:#f92672>.</span>current_token <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>nodes<span style=color:#f92672>.</span>append(self<span style=color:#f92672>.</span>expr())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>source <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    2 + 2 + (3 + 4)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    1 * 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> Tokenizer(source)
</span></span><span style=display:flex><span>t<span style=color:#f92672>.</span>tokenize()
</span></span><span style=display:flex><span>builder <span style=color:#f92672>=</span> AstBuilder(t<span style=color:#f92672>.</span>tokens())
</span></span><span style=display:flex><span>builder<span style=color:#f92672>.</span>build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> builder<span style=color:#f92672>.</span>nodes:
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> builder<span style=color:#f92672>.</span>calculate(node)
</span></span><span style=display:flex><span>    print(result)
</span></span></code></pre></div><p>The above code is an extension of whatever was discussed, extending PLUS and MULTIPLY to MINUS, DIVIDE, LPAREN, and RPAREN as well. This will change according to the grammar
of the language.</p><p>The walk method, does a tree traversal and prints out the value of the node. This technique is used in the calculate method to combine and calculate the result instead of just
printing.</p><p><a href=https://github.com/manosriram/ast>Code Repository</a></p></content><p></p></main><footer></footer><script>function toggleTheme(){const t=document.body,s=t.getAttribute("data-theme")||"light",e=s==="dark"?"light":"dark";t.setAttribute("data-theme",e),localStorage.setItem("theme",e);const n=document.querySelector(".theme-toggle");n&&(n.textContent=e==="dark"?"‚òÄÔ∏è":"üåô")}function initializeTheme(){const t=localStorage.getItem("theme")||"light";document.body.setAttribute("data-theme",t);const e=document.querySelector(".theme-toggle");e?(e.textContent=t==="dark"?"‚òÄÔ∏è":"üåô",e.addEventListener("click",toggleTheme)):setTimeout(initializeTheme,100)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",initializeTheme):initializeTheme()</script></body></html>