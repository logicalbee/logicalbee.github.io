<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Sushanth Kurdekar</title><link>https://logicalbee.github.io/posts/</link><description>Recent content in Posts on Sushanth Kurdekar</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 23 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://logicalbee.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How i make use of LLMs</title><link>https://logicalbee.github.io/posts/llm/</link><pubDate>Wed, 23 Apr 2025 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/llm/</guid><description>&lt;p&gt;Frequency of the use of LLMs have increased a lot for me in the past year specifically. I use claude as my daily driver. I do not pay for the pro plan, but I do have API credits to work with which I am going to talk about.&lt;/p&gt;
&lt;h3 id="aider"&gt;Aider&lt;/h3&gt;
&lt;p&gt;Recently discovered this tool to interact locally using codebases. This works great for me. Its very convenient to use llms from the terminal.&lt;/p&gt;</description></item><item><title>Abstract syntax trees</title><link>https://logicalbee.github.io/posts/abstract-syntax-trees/</link><pubDate>Sun, 12 Jan 2025 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/abstract-syntax-trees/</guid><description>&lt;p&gt;ASTs are a representation of the code. It converts a bunch of meaningless tokens into a tree which represents the code.
When the code is seen in the form of tree, multiple usecases arise such as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static code analysis - Analyze and find issues in code without executing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform code - ASTs can be used to transform code to some other form.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We will try to create an AST for the expression &amp;lsquo;1 + 2 * 3&amp;rsquo;. Since this is a single expression, there will be one node. If there are multiple expressions and statements, we store them separately
in a list and execute them separately.&lt;/p&gt;</description></item><item><title>Making time to learn software design patterns</title><link>https://logicalbee.github.io/posts/design-patterns/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/design-patterns/</guid><description>&lt;p&gt;Inorder to write well structured, extensible, and readable code - design patterns help. I have recently started to read and follow more on this path. Until now, I didn&amp;rsquo;t care much about these patterns (although some design patterns are just patterns we do frequently without knowing).&lt;/p&gt;
&lt;p&gt;In 1994, 4 people came together to write the book &lt;code&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/code&gt;. It became a standard for the design patterns and since then the book was also called as &lt;code&gt;The gang-of-four(gof) book&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Handling concurrency in KeyValue stores</title><link>https://logicalbee.github.io/posts/key-value-concurrency/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/key-value-concurrency/</guid><description>&lt;p&gt;Key value stores might seem simple from outer view. We set and get the values which I thought the same. However, things get tricky as we dive deep. The problem is that, what happens if few processes write a key at the same time, and few processes read the same key.&lt;/p&gt;
&lt;p&gt;We can actually simulate this using &lt;code&gt;goroutines&lt;/code&gt; in golang.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;numGoRoutines&lt;/span&gt; &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;wg&lt;/span&gt; &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sync&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;WaitGroup&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;wg&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Add&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;numGoRoutines&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;i&lt;/span&gt; &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; &lt;span style="color:#a6e22e"&gt;i&lt;/span&gt; &amp;lt; &lt;span style="color:#a6e22e"&gt;numGoRoutines&lt;/span&gt;; &lt;span style="color:#a6e22e"&gt;i&lt;/span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;kv&lt;/span&gt; &lt;span style="color:#f92672"&gt;:=&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;nimbusdb&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;KeyValuePair&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;Key&lt;/span&gt;: []byte(&lt;span style="color:#a6e22e"&gt;fmt&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Sprintf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;i&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;Value&lt;/span&gt;: []byte(&lt;span style="color:#a6e22e"&gt;fmt&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Sprintf&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;testvalue%d&amp;#34;&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;i&lt;/span&gt;)),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;go&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#66d9ef"&gt;defer&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;wg&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;writtenKvPair&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;err&lt;/span&gt; = &lt;span style="color:#a6e22e"&gt;d&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Set&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;kv&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;wg&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above code creates 1000 goroutines each setting a different value. But, the problem is that multiple go routines can touch the variable where the keyvalue pairs are stored. Why is that a problem? Because we want to be 100% sure that only one process is using the variable at a given moment, which you might have guessed that we&amp;rsquo;ll use locks.&lt;/p&gt;</description></item><item><title>Key Value Store internals</title><link>https://logicalbee.github.io/posts/key-value-stores/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://logicalbee.github.io/posts/key-value-stores/</guid><description>&lt;h1 id="key-value-store-and-a-cache"&gt;Key Value store and a Cache&lt;/h1&gt;
&lt;p&gt;Doesn&amp;rsquo;t Cache use key value to store objects? Then why do we need a key value store?&lt;/p&gt;
&lt;p&gt;The answer is simple, persistence.
A key-value store is a database but instead of tables and other complex stuff, we simply use a key value structure. Cache&amp;rsquo;s main purpose is to increase read performance.
Anything you think doesnt change that often, you can cache it. Whereas, KV store focuses more on writes along with reads.&lt;/p&gt;</description></item></channel></rss>